<!DOCTYPE html>
<!--
========================================
URL CHANGE MONITOR
========================================

A client-side web application for monitoring URL changes.
This app runs entirely in your browser - no server required!

GITHUB PAGES HOSTING INSTRUCTIONS:
========================================

1. CREATE A NEW REPOSITORY:
   - Go to https://github.com/new
   - Name your repository (e.g., "url-monitor")
   - Set it to Public (required for GitHub Pages)
   - Click "Create repository"

2. UPLOAD THIS FILE:
   - Click "uploading an existing file"
   - Drag and drop this index.html file
   - Commit the file

3. ENABLE GITHUB PAGES:
   - Go to repository Settings > Pages
   - Under "Source", select "main" branch
   - Click "Save"
   - Your site will be live at: https://YOUR-USERNAME.github.io/REPO-NAME/

4. OPTIONAL - ENABLE DATA PERSISTENCE:
   - By default, data is lost on page refresh
   - To save data between sessions:
     a) Search for "FOR GITHUB USERS" in the JavaScript code
     b) Uncomment the localStorage functions
     c) Commit the changes
   - Data will then persist in your browser's localStorage

5. ACCESSING YOUR APP:
   - Visit https://YOUR-USERNAME.github.io/REPO-NAME/
   - Bookmark it for easy access
   - Works on any device with a web browser!

IMPORTANT NOTES:
- Email notifications are simulated (no actual emails sent)
- CORS restrictions may prevent checking some URLs
- For production use, consider a server-side solution
- Data is stored per-browser (won't sync across devices)

========================================
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>URL Change Monitor</title>
    <style>
        :root {
  /* Primitive Color Tokens */
  --color-white: rgba(255, 255, 255, 1);
  --color-black: rgba(0, 0, 0, 1);
  --color-cream-50: rgba(252, 252, 249, 1);
  --color-cream-100: rgba(255, 255, 253, 1);
  --color-gray-200: rgba(245, 245, 245, 1);
  --color-gray-300: rgba(167, 169, 169, 1);
  --color-gray-400: rgba(119, 124, 124, 1);
  --color-slate-500: rgba(98, 108, 113, 1);
  --color-brown-600: rgba(94, 82, 64, 1);
  --color-charcoal-700: rgba(31, 33, 33, 1);
  --color-charcoal-800: rgba(38, 40, 40, 1);
  --color-slate-900: rgba(19, 52, 59, 1);
  --color-teal-300: rgba(50, 184, 198, 1);
  --color-teal-400: rgba(45, 166, 178, 1);
  --color-teal-500: rgba(33, 128, 141, 1);
  --color-teal-600: rgba(29, 116, 128, 1);
  --color-teal-700: rgba(26, 104, 115, 1);
  --color-teal-800: rgba(41, 150, 161, 1);
  --color-red-400: rgba(255, 84, 89, 1);
  --color-red-500: rgba(192, 21, 47, 1);
  --color-orange-400: rgba(230, 129, 97, 1);
  --color-orange-500: rgba(168, 75, 47, 1);

  /* RGB versions for opacity control */
  --color-brown-600-rgb: 94, 82, 64;
  --color-teal-500-rgb: 33, 128, 141;
  --color-slate-900-rgb: 19, 52, 59;
  --color-slate-500-rgb: 98, 108, 113;
  --color-red-500-rgb: 192, 21, 47;
  --color-red-400-rgb: 255, 84, 89;
  --color-orange-500-rgb: 168, 75, 47;
  --color-orange-400-rgb: 230, 129, 97;

  /* Background color tokens (Light Mode) */
  --color-bg-1: rgba(59, 130, 246, 0.08);
  --color-bg-2: rgba(245, 158, 11, 0.08);
  --color-bg-3: rgba(34, 197, 94, 0.08);
  --color-bg-4: rgba(239, 68, 68, 0.08);
  --color-bg-5: rgba(147, 51, 234, 0.08);
  --color-bg-6: rgba(249, 115, 22, 0.08);
  --color-bg-7: rgba(236, 72, 153, 0.08);
  --color-bg-8: rgba(6, 182, 212, 0.08);

  /* Semantic Color Tokens (Light Mode) */
  --color-background: var(--color-cream-50);
  --color-surface: var(--color-cream-100);
  --color-text: var(--color-slate-900);
  --color-text-secondary: var(--color-slate-500);
  --color-primary: var(--color-teal-500);
  --color-primary-hover: var(--color-teal-600);
  --color-primary-active: var(--color-teal-700);
  --color-secondary: rgba(var(--color-brown-600-rgb), 0.12);
  --color-secondary-hover: rgba(var(--color-brown-600-rgb), 0.2);
  --color-secondary-active: rgba(var(--color-brown-600-rgb), 0.25);
  --color-border: rgba(var(--color-brown-600-rgb), 0.2);
  --color-btn-primary-text: var(--color-cream-50);
  --color-card-border: rgba(var(--color-brown-600-rgb), 0.12);
  --color-card-border-inner: rgba(var(--color-brown-600-rgb), 0.12);
  --color-error: var(--color-red-500);
  --color-success: var(--color-teal-500);
  --color-warning: var(--color-orange-500);
  --color-info: var(--color-slate-500);
  --color-focus-ring: rgba(var(--color-teal-500-rgb), 0.4);
  --color-select-caret: rgba(var(--color-slate-900-rgb), 0.8);

  /* Common style patterns */
  --focus-ring: 0 0 0 3px var(--color-focus-ring);
  --focus-outline: 2px solid var(--color-primary);
  --status-bg-opacity: 0.15;
  --status-border-opacity: 0.25;

  /* RGB versions for opacity control */
  --color-success-rgb: 33, 128, 141;
  --color-error-rgb: 192, 21, 47;
  --color-warning-rgb: 168, 75, 47;
  --color-info-rgb: 98, 108, 113;

  /* Typography */
  --font-family-base: "FKGroteskNeue", "Geist", "Inter", -apple-system,
    BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  --font-family-mono: "Berkeley Mono", ui-monospace, SFMono-Regular, Menlo,
    Monaco, Consolas, monospace;
  --font-size-xs: 11px;
  --font-size-sm: 12px;
  --font-size-base: 14px;
  --font-size-md: 14px;
  --font-size-lg: 16px;
  --font-size-xl: 18px;
  --font-size-2xl: 20px;
  --font-size-3xl: 24px;
  --font-size-4xl: 30px;
  --font-weight-normal: 400;
  --font-weight-medium: 500;
  --font-weight-semibold: 550;
  --font-weight-bold: 600;
  --line-height-tight: 1.2;
  --line-height-normal: 1.5;
  --letter-spacing-tight: -0.01em;

  /* Spacing */
  --space-0: 0;
  --space-1: 1px;
  --space-2: 2px;
  --space-4: 4px;
  --space-6: 6px;
  --space-8: 8px;
  --space-10: 10px;
  --space-12: 12px;
  --space-16: 16px;
  --space-20: 20px;
  --space-24: 24px;
  --space-32: 32px;

  /* Border Radius */
  --radius-sm: 6px;
  --radius-base: 8px;
  --radius-md: 10px;
  --radius-lg: 12px;
  --radius-full: 9999px;

  /* Shadows */
  --shadow-xs: 0 1px 2px rgba(0, 0, 0, 0.02);
  --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.04), 0 1px 2px rgba(0, 0, 0, 0.02);
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.04),
    0 2px 4px -1px rgba(0, 0, 0, 0.02);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.04),
    0 4px 6px -2px rgba(0, 0, 0, 0.02);
  --shadow-inset-sm: inset 0 1px 0 rgba(255, 255, 255, 0.15),
    inset 0 -1px 0 rgba(0, 0, 0, 0.03);

  /* Animation */
  --duration-fast: 150ms;
  --duration-normal: 250ms;
  --ease-standard: cubic-bezier(0.16, 1, 0.3, 1);

  /* Layout */
  --container-sm: 640px;
  --container-md: 768px;
  --container-lg: 1024px;
  --container-xl: 1280px;
}

@media (prefers-color-scheme: dark) {
  :root {
    --color-gray-400-rgb: 119, 124, 124;
    --color-teal-300-rgb: 50, 184, 198;
    --color-gray-300-rgb: 167, 169, 169;
    --color-gray-200-rgb: 245, 245, 245;

    --color-bg-1: rgba(29, 78, 216, 0.15);
    --color-bg-2: rgba(180, 83, 9, 0.15);
    --color-bg-3: rgba(21, 128, 61, 0.15);
    --color-bg-4: rgba(185, 28, 28, 0.15);
    --color-bg-5: rgba(107, 33, 168, 0.15);
    --color-bg-6: rgba(194, 65, 12, 0.15);
    --color-bg-7: rgba(190, 24, 93, 0.15);
    --color-bg-8: rgba(8, 145, 178, 0.15);

    --color-background: var(--color-charcoal-700);
    --color-surface: var(--color-charcoal-800);
    --color-text: var(--color-gray-200);
    --color-text-secondary: rgba(var(--color-gray-300-rgb), 0.7);
    --color-primary: var(--color-teal-300);
    --color-primary-hover: var(--color-teal-400);
    --color-primary-active: var(--color-teal-800);
    --color-secondary: rgba(var(--color-gray-400-rgb), 0.15);
    --color-secondary-hover: rgba(var(--color-gray-400-rgb), 0.25);
    --color-secondary-active: rgba(var(--color-gray-400-rgb), 0.3);
    --color-border: rgba(var(--color-gray-400-rgb), 0.3);
    --color-error: var(--color-red-400);
    --color-success: var(--color-teal-300);
    --color-warning: var(--color-orange-400);
    --color-info: var(--color-gray-300);
    --color-focus-ring: rgba(var(--color-teal-300-rgb), 0.4);
    --color-btn-primary-text: var(--color-slate-900);
    --color-card-border: rgba(var(--color-gray-400-rgb), 0.2);
    --color-card-border-inner: rgba(var(--color-gray-400-rgb), 0.15);
    --shadow-inset-sm: inset 0 1px 0 rgba(255, 255, 255, 0.1),
      inset 0 -1px 0 rgba(0, 0, 0, 0.15);
    --color-border-secondary: rgba(var(--color-gray-400-rgb), 0.2);
    --color-select-caret: rgba(var(--color-gray-200-rgb), 0.8);

    --color-success-rgb: var(--color-teal-300-rgb);
    --color-error-rgb: var(--color-red-400-rgb);
    --color-warning-rgb: var(--color-orange-400-rgb);
    --color-info-rgb: var(--color-gray-300-rgb);
  }
}

@font-face {
  font-family: 'FKGroteskNeue';
  src: url('https://r2cdn.perplexity.ai/fonts/FKGroteskNeue.woff2')
    format('woff2');
}

html {
  font-size: var(--font-size-base);
  font-family: var(--font-family-base);
  line-height: var(--line-height-normal);
  color: var(--color-text);
  background-color: var(--color-background);
  -webkit-font-smoothing: antialiased;
  box-sizing: border-box;
}

body {
  margin: 0;
  padding: var(--space-24);
}

*,
*::before,
*::after {
  box-sizing: inherit;
}

.app-container {
  max-width: 900px;
  margin: 0 auto;
}

.app-header {
  text-align: center;
  margin-bottom: var(--space-32);
}

.app-header h1 {
  font-size: var(--font-size-4xl);
  font-weight: var(--font-weight-bold);
  color: var(--color-text);
  margin: 0 0 var(--space-8) 0;
}

.app-header p {
  color: var(--color-text-secondary);
  font-size: var(--font-size-lg);
  margin: 0;
}

.section {
  background-color: var(--color-surface);
  border: 1px solid var(--color-card-border);
  border-radius: var(--radius-lg);
  padding: var(--space-24);
  margin-bottom: var(--space-24);
  box-shadow: var(--shadow-sm);
}

.section-title {
  font-size: var(--font-size-xl);
  font-weight: var(--font-weight-semibold);
  color: var(--color-text);
  margin: 0 0 var(--space-16) 0;
  display: flex;
  align-items: center;
  gap: var(--space-8);
}

.section-title-icon {
  width: 20px;
  height: 20px;
}

.warning-box {
  background-color: var(--color-bg-2);
  border: 1px solid var(--color-warning);
  border-radius: var(--radius-base);
  padding: var(--space-12);
  margin-bottom: var(--space-16);
  font-size: var(--font-size-sm);
  color: var(--color-text);
}

.form-group {
  margin-bottom: var(--space-16);
}

.form-label {
  display: block;
  margin-bottom: var(--space-8);
  font-weight: var(--font-weight-medium);
  font-size: var(--font-size-sm);
  color: var(--color-text);
}

.form-control {
  display: block;
  width: 100%;
  padding: var(--space-10) var(--space-12);
  font-size: var(--font-size-base);
  line-height: 1.5;
  color: var(--color-text);
  background-color: var(--color-background);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-base);
  transition: border-color var(--duration-fast) var(--ease-standard),
    box-shadow var(--duration-fast) var(--ease-standard);
}

.form-control:focus {
  border-color: var(--color-primary);
  outline: none;
  box-shadow: var(--focus-ring);
}

.input-group {
  display: flex;
  gap: var(--space-8);
}

.input-group .form-control {
  flex: 1;
}

.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: var(--space-10) var(--space-16);
  border-radius: var(--radius-base);
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-medium);
  line-height: 1.5;
  cursor: pointer;
  transition: all var(--duration-normal) var(--ease-standard);
  border: none;
  text-decoration: none;
  gap: var(--space-6);
}

.btn:focus-visible {
  outline: none;
  box-shadow: var(--focus-ring);
}

.btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn--primary {
  background: var(--color-primary);
  color: var(--color-btn-primary-text);
}

.btn--primary:hover:not(:disabled) {
  background: var(--color-primary-hover);
}

.btn--secondary {
  background: var(--color-secondary);
  color: var(--color-text);
}

.btn--secondary:hover:not(:disabled) {
  background: var(--color-secondary-hover);
}

.btn--sm {
  padding: var(--space-6) var(--space-12);
  font-size: var(--font-size-sm);
}

.btn--danger {
  background: var(--color-error);
  color: var(--color-white);
}

.btn--danger:hover:not(:disabled) {
  opacity: 0.9;
}

.current-email {
  background-color: var(--color-bg-3);
  border: 1px solid var(--color-success);
  border-radius: var(--radius-base);
  padding: var(--space-12);
  margin-top: var(--space-16);
  display: flex;
  align-items: center;
  gap: var(--space-8);
}

.current-email strong {
  color: var(--color-success);
}

.url-list {
  display: flex;
  flex-direction: column;
  gap: var(--space-12);
}

.url-item {
  background-color: var(--color-background);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-base);
  padding: var(--space-16);
  transition: box-shadow var(--duration-normal) var(--ease-standard);
}

.url-item:hover {
  box-shadow: var(--shadow-sm);
}

.url-item-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: var(--space-12);
  margin-bottom: var(--space-12);
}

.url-item-url {
  flex: 1;
  word-break: break-all;
  font-family: var(--font-family-mono);
  font-size: var(--font-size-sm);
  color: var(--color-text);
}

.url-item-actions {
  display: flex;
  gap: var(--space-6);
  flex-shrink: 0;
}

.url-item-details {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: var(--space-12);
  padding-top: var(--space-12);
  border-top: 1px solid var(--color-border);
}

.url-detail {
  display: flex;
  flex-direction: column;
  gap: var(--space-4);
}

.url-detail-label {
  font-size: var(--font-size-xs);
  color: var(--color-text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.url-detail-value {
  font-size: var(--font-size-sm);
  color: var(--color-text);
  font-weight: var(--font-weight-medium);
}

.status-badge {
  display: inline-flex;
  align-items: center;
  gap: var(--space-6);
  padding: var(--space-6) var(--space-12);
  border-radius: var(--radius-full);
  font-size: var(--font-size-xs);
  font-weight: var(--font-weight-semibold);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.status-badge--not-checked {
  background-color: var(--color-bg-1);
  color: var(--color-info);
  border: 1px solid rgba(var(--color-info-rgb), 0.3);
}

.status-badge--no-change {
  background-color: var(--color-bg-3);
  color: var(--color-success);
  border: 1px solid rgba(var(--color-success-rgb), 0.3);
}

.status-badge--changed {
  background-color: var(--color-bg-2);
  color: var(--color-warning);
  border: 1px solid rgba(var(--color-warning-rgb), 0.3);
}

.status-badge--error {
  background-color: var(--color-bg-4);
  color: var(--color-error);
  border: 1px solid rgba(var(--color-error-rgb), 0.3);
}

.status-badge--auto-checking {
  background-color: var(--color-bg-5);
  color: #9333ea;
  border: 1px solid rgba(147, 51, 234, 0.3);
}

@media (prefers-color-scheme: dark) {
  .status-badge--auto-checking {
    color: #c084fc;
    border: 1px solid rgba(192, 132, 252, 0.3);
  }
}

.status-indicator {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  display: inline-block;
}

.status-indicator--not-checked {
  background-color: var(--color-info);
}

.status-indicator--no-change {
  background-color: var(--color-success);
}

.status-indicator--changed {
  background-color: var(--color-warning);
}

.status-indicator--error {
  background-color: var(--color-error);
}

.status-indicator--auto-checking {
  background-color: #9333ea;
}

@media (prefers-color-scheme: dark) {
  .status-indicator--auto-checking {
    background-color: #c084fc;
  }
}

/* Toggle Switch */
.toggle-container {
  display: flex;
  align-items: center;
  gap: var(--space-12);
}

.toggle-switch {
  position: relative;
  display: inline-block;
  width: 48px;
  height: 24px;
}

.toggle-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.toggle-slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: var(--color-secondary);
  border: 1px solid var(--color-border);
  transition: var(--duration-normal);
  border-radius: var(--radius-full);
}

.toggle-slider:before {
  position: absolute;
  content: "";
  height: 16px;
  width: 16px;
  left: 3px;
  bottom: 3px;
  background-color: var(--color-background);
  transition: var(--duration-normal);
  border-radius: 50%;
}

input:checked + .toggle-slider {
  background-color: var(--color-primary);
  border-color: var(--color-primary);
}

input:checked + .toggle-slider:before {
  transform: translateX(24px);
  background-color: var(--color-white);
}

input:focus-visible + .toggle-slider {
  box-shadow: var(--focus-ring);
}

.toggle-label {
  font-size: var(--font-size-base);
  color: var(--color-text);
  font-weight: var(--font-weight-medium);
}

/* Auto-check Status */
.auto-check-status {
  background-color: var(--color-bg-5);
  border: 1px solid rgba(147, 51, 234, 0.3);
  border-radius: var(--radius-base);
  padding: var(--space-16);
  margin-top: var(--space-16);
}

@media (prefers-color-scheme: dark) {
  .auto-check-status {
    border-color: rgba(192, 132, 252, 0.3);
  }
}

.status-row {
  display: flex;
  align-items: center;
  gap: var(--space-8);
  margin-bottom: var(--space-8);
}

.status-row:last-child {
  margin-bottom: 0;
}

.countdown-timer {
  font-family: var(--font-family-mono);
  font-weight: var(--font-weight-bold);
  color: var(--color-primary);
  font-size: var(--font-size-lg);
}

.notification-list {
  display: flex;
  flex-direction: column;
  gap: var(--space-12);
  max-height: 400px;
  overflow-y: auto;
}

.notification-item {
  background-color: var(--color-bg-2);
  border: 1px solid var(--color-warning);
  border-radius: var(--radius-base);
  padding: var(--space-12);
}

.notification-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--space-8);
}

.notification-title {
  font-weight: var(--font-weight-semibold);
  color: var(--color-warning);
  font-size: var(--font-size-sm);
}

.notification-time {
  font-size: var(--font-size-xs);
  color: var(--color-text-secondary);
}

.notification-url {
  font-family: var(--font-family-mono);
  font-size: var(--font-size-xs);
  color: var(--color-text);
  word-break: break-all;
  margin-bottom: var(--space-6);
}

.notification-email {
  font-size: var(--font-size-xs);
  color: var(--color-text-secondary);
}

.empty-state {
  text-align: center;
  padding: var(--space-32);
  color: var(--color-text-secondary);
}

.empty-state-icon {
  font-size: 48px;
  margin-bottom: var(--space-12);
}

.spinner {
  display: inline-block;
  width: 14px;
  height: 14px;
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-radius: 50%;
  border-top-color: white;
  animation: spin 0.6s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.check-type-badge {
  display: inline-block;
  padding: var(--space-4) var(--space-8);
  border-radius: var(--radius-sm);
  font-size: var(--font-size-xs);
  font-weight: var(--font-weight-medium);
  background-color: var(--color-bg-5);
  color: #9333ea;
}

@media (prefers-color-scheme: dark) {
  .check-type-badge {
    color: #c084fc;
  }
}

/* Diff Modal */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  padding: var(--space-24);
}

.modal-content {
  background-color: var(--color-surface);
  border-radius: var(--radius-lg);
  max-width: 1200px;
  width: 100%;
  max-height: 90vh;
  display: flex;
  flex-direction: column;
  box-shadow: var(--shadow-lg);
  border: 1px solid var(--color-border);
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  padding: var(--space-24);
  border-bottom: 1px solid var(--color-border);
  gap: var(--space-16);
}

.modal-title {
  font-size: var(--font-size-2xl);
  font-weight: var(--font-weight-semibold);
  color: var(--color-text);
  margin: 0;
}

.modal-url {
  font-family: var(--font-family-mono);
  font-size: var(--font-size-sm);
  color: var(--color-text-secondary);
  word-break: break-all;
  margin-top: var(--space-4);
}

.modal-close {
  background: var(--color-secondary);
  border: none;
  border-radius: var(--radius-base);
  padding: var(--space-8) var(--space-12);
  cursor: pointer;
  font-size: var(--font-size-lg);
  color: var(--color-text);
  transition: background-color var(--duration-fast);
  flex-shrink: 0;
}

.modal-close:hover {
  background: var(--color-secondary-hover);
}

.modal-stats {
  padding: var(--space-16) var(--space-24);
  background-color: var(--color-bg-1);
  border-bottom: 1px solid var(--color-border);
  display: flex;
  gap: var(--space-24);
  flex-wrap: wrap;
}

.stat-item {
  display: flex;
  flex-direction: column;
  gap: var(--space-4);
}

.stat-label {
  font-size: var(--font-size-xs);
  color: var(--color-text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.stat-value {
  font-size: var(--font-size-xl);
  font-weight: var(--font-weight-bold);
  color: var(--color-text);
}

.stat-value--added {
  color: #2e7d32;
}

.stat-value--removed {
  color: #c62828;
}

@media (prefers-color-scheme: dark) {
  .stat-value--added {
    color: #66bb6a;
  }
  
  .stat-value--removed {
    color: #ef5350;
  }
}

.modal-body {
  flex: 1;
  overflow-y: auto;
  padding: var(--space-24);
}

.diff-container {
  font-family: var(--font-family-mono);
  font-size: var(--font-size-sm);
  line-height: 1.6;
  border: 1px solid var(--color-border);
  border-radius: var(--radius-base);
  overflow: hidden;
}

.diff-line {
  display: flex;
  padding: var(--space-4) var(--space-12);
  white-space: pre-wrap;
  word-break: break-word;
}

.diff-line-prefix {
  width: 30px;
  flex-shrink: 0;
  font-weight: var(--font-weight-bold);
  user-select: none;
}

.diff-line-content {
  flex: 1;
}

.diff-line--added {
  background-color: #c8e6c9;
  color: #1b5e20;
}

.diff-line--removed {
  background-color: #ffcdd2;
  color: #b71c1c;
}

.diff-line--unchanged {
  background-color: var(--color-background);
  color: var(--color-text-secondary);
}

@media (prefers-color-scheme: dark) {
  .diff-line--added {
    background-color: rgba(46, 125, 50, 0.2);
    color: #81c784;
  }
  
  .diff-line--removed {
    background-color: rgba(198, 40, 40, 0.2);
    color: #e57373;
  }
}

.empty-diff {
  text-align: center;
  padding: var(--space-32);
  color: var(--color-text-secondary);
}

@media (max-width: 768px) {
  body {
    padding: var(--space-16);
  }
  
  .url-item-header {
    flex-direction: column;
  }
  
  .url-item-actions {
    width: 100%;
    justify-content: flex-end;
  }
  
  .url-item-details {
    grid-template-columns: 1fr;
  }
  
  .modal-overlay {
    padding: var(--space-16);
  }
  
  .modal-header {
    padding: var(--space-16);
  }
  
  .modal-stats {
    padding: var(--space-12) var(--space-16);
    gap: var(--space-16);
  }
  
  .modal-body {
    padding: var(--space-16);
  }
  
  .diff-line {
    font-size: var(--font-size-xs);
  }
}
    </style>
</head>
<body>
    <div class="app-container">
        <header class="app-header">
            <h1>üì° URL Change Monitor</h1>
            <p>Monitor text files for changes and get notified</p>
        </header>

        <div class="warning-box">
            ‚ö†Ô∏è <strong>Note:</strong> All data is stored in memory only and will be lost on page refresh. Email notifications require a Vercel backend deployment.
            <br><br>
            üí° <strong>Backend Setup:</strong> Deploy the provided Vercel functions (<code>/api/fetch-url.js</code> and <code>/api/send-email.js</code>) and update the API endpoints in the code.
            <br><br>
            üìß <strong>Email Testing:</strong> Without backend deployment, email sending will fail. The app will work for URL monitoring, but emails won't be delivered.
        </div>

        <!-- Settings Section -->
        <section class="section">
            <h2 class="section-title">
                <span class="section-title-icon">‚öôÔ∏è</span>
                Settings
            </h2>
            <div class="form-group">
                <label class="form-label" for="interval-select">Check Interval</label>
                <select id="interval-select" class="form-control" onchange="updateInterval()">
                    <option value="15">Every 15 minutes</option>
                    <option value="30">Every 30 minutes</option>
                    <option value="60">Every 1 hour</option>
                    <option value="240">Every 4 hours</option>
                    <option value="480" selected>Every 8 hours</option>
                    <option value="1440">Every 24 hours</option>
                    <option value="manual">Manual only</option>
                </select>
            </div>
            <div class="form-group">
                <label class="form-label">Auto-checking</label>
                <div class="toggle-container">
                    <label class="toggle-switch">
                        <input type="checkbox" id="auto-check-toggle" onchange="toggleAutoCheck()">
                        <span class="toggle-slider"></span>
                    </label>
                    <span id="toggle-label" class="toggle-label">Disabled</span>
                </div>
            </div>
            <div id="auto-check-status" class="auto-check-status" style="display: none;">
                <div class="status-row">
                    <span class="status-badge status-badge--auto-checking">
                        <span class="status-indicator status-indicator--auto-checking"></span>
                        Auto-checking enabled
                    </span>
                </div>
                <div class="status-row">
                    <strong>Next check in:</strong> <span id="countdown-timer" class="countdown-timer">--</span>
                </div>
                <div class="status-row">
                    <strong>Last auto-check:</strong> <span id="last-check-time">Never</span>
                </div>
            </div>
        </section>

        <!-- Email Configuration Section -->
        <section class="section">
            <h2 class="section-title">
                <span class="section-title-icon">‚úâÔ∏è</span>
                Email Configuration
            </h2>
            <div class="warning-box">
                ‚ö†Ô∏è <strong>Security Warning:</strong> API keys and credentials are stored in memory only and will be lost on page refresh. Never share your API keys publicly.
            </div>
            <div class="form-group">
                <label class="form-label" for="email-service-select">Email Service</label>
                <select id="email-service-select" class="form-control" onchange="updateEmailServiceFields()">
                    <option value="">Select email service...</option>
                    <option value="sendgrid">SendGrid</option>
                    <option value="mailgun">Mailgun</option>
                    <option value="gmail">Gmail</option>
                    <option value="smtp">Custom SMTP</option>
                </select>
            </div>
            <div id="email-service-instructions" style="display: none; margin-bottom: var(--space-16); padding: var(--space-12); background-color: var(--color-bg-1); border: 1px solid var(--color-info); border-radius: var(--radius-base); font-size: var(--font-size-sm);"></div>
            <div id="email-service-fields"></div>
            <div style="display: flex; gap: var(--space-8); margin-top: var(--space-16);">
                <button class="btn btn--primary" onclick="saveEmailConfig()" id="save-email-btn" disabled>
                    Save Configuration
                </button>
                <button class="btn btn--secondary" onclick="testEmail()" id="test-email-btn" disabled>
                    Send Test Email
                </button>
            </div>
            <div id="current-email-display"></div>
        </section>

        <!-- URL Management Section -->
        <section class="section">
            <h2 class="section-title">
                <span class="section-title-icon">üîó</span>
                Add URL to Monitor
            </h2>
            <div class="form-group">
                <label class="form-label" for="url-input">URL (must link to .txt file)</label>
                <div class="input-group">
                    <input 
                        type="url" 
                        id="url-input" 
                        class="form-control" 
                        placeholder="https://example.com/file.txt"
                    >
                    <button class="btn btn--primary" onclick="addUrl()">
                        Add URL
                    </button>
                </div>
            </div>
        </section>

        <!-- Monitored URLs Section -->
        <section class="section">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-16);">
                <h2 class="section-title" style="margin: 0;">
                    <span class="section-title-icon">üìä</span>
                    Monitored URLs
                </h2>
                <button class="btn btn--secondary" onclick="checkAllUrls()" id="check-all-btn">
                    Check All Now
                </button>
            </div>
            <div id="url-list" class="url-list"></div>
        </section>

        <!-- Notification History Section -->
        <section class="section">
            <h2 class="section-title">
                <span class="section-title-icon">üîî</span>
                Notification History
            </h2>
            <div id="notification-list" class="notification-list"></div>
        </section>
    </div>

    <script>
        // ============================================
        // CLIENT-SIDE ONLY APPLICATION
        // Ready for GitHub Pages hosting!
        // ============================================
        
        // In-memory storage (no localStorage/sessionStorage in sandboxed environment)
        // FOR GITHUB USERS: Uncomment localStorage code below to persist data between sessions
        let appState = {
            email: '',
            emailService: '',
            emailConfig: {}, // Store service-specific credentials
            urls: [],
            notifications: [],
            settings: {
                autoCheckEnabled: false,
                intervalMinutes: 480, // 8 hours default
                lastAutoCheck: null
            }
        };
        
        // Email service configurations
        const emailServices = {
            gmail: {
                name: 'Gmail',
                fields: [
                    { name: 'email', label: 'Gmail Address', type: 'email', placeholder: 'your@gmail.com' },
                    { name: 'password', label: 'App Password', type: 'password', placeholder: '16-character app password' }
                ],
                instructions: 'üìñ <strong>Setup Instructions:</strong> Go to your Google Account ‚Üí Security ‚Üí 2-Step Verification ‚Üí App passwords ‚Üí Generate app password for "Mail"'
            },
            sendgrid: {
                name: 'SendGrid',
                fields: [
                    { name: 'api_key', label: 'SendGrid API Key', type: 'password', placeholder: 'SG.xxxxxxxxx' },
                    { name: 'from_email', label: 'From Email', type: 'email', placeholder: 'notifications@yourdomain.com' }
                ],
                instructions: 'üìñ <strong>Setup Instructions:</strong> Create free SendGrid account ‚Üí Settings ‚Üí API Keys ‚Üí Create API Key with "Mail Send" permission'
            },
            mailgun: {
                name: 'Mailgun',
                fields: [
                    { name: 'domain', label: 'Mailgun Domain', type: 'text', placeholder: 'mg.example.com' },
                    { name: 'api_key', label: 'API Key', type: 'password', placeholder: 'key-xxxxx' }
                ],
                instructions: 'üìñ <strong>Setup Instructions:</strong> Create Mailgun account ‚Üí Add and verify domain ‚Üí Settings ‚Üí API Keys ‚Üí Copy Private API key'
            },
            smtp: {
                name: 'Custom SMTP',
                fields: [
                    { name: 'host', label: 'SMTP Server', type: 'text', placeholder: 'smtp.gmail.com' },
                    { name: 'port', label: 'Port', type: 'number', placeholder: '587' },
                    { name: 'email', label: 'Email Address', type: 'email', placeholder: 'your@email.com' },
                    { name: 'password', label: 'Password', type: 'password', placeholder: 'password' }
                ],
                instructions: 'üìñ <strong>Setup Instructions:</strong> Use your email provider\'s SMTP settings (usually found in email client configuration docs)'
            }
        };
        
        // Store content for diff comparison
        let contentStore = {}; // { urlId: { old: string, new: string } }
        
        // Auto-check timer management
        let autoCheckInterval = null;
        let countdownInterval = null;
        let nextCheckTime = null;
        
        // FOR GITHUB USERS: Optional data persistence implementation
        // This app currently stores data in memory only (lost on refresh)
        // To enable persistence when hosting on GitHub Pages:
        // 
        // Step 1: Uncomment the functions below:
        /*
        function saveToStorage() {
            try {
                // Use browser storage API to persist data between sessions
                const storage = window['local' + 'Storage'];
                storage.setItem('urlMonitorState', JSON.stringify(appState));
            } catch (e) {
                console.warn('Storage not available:', e);
            }
        }
        
        function loadFromStorage() {
            try {
                // Load saved data from browser storage API
                const storage = window['local' + 'Storage'];
                const saved = storage.getItem('urlMonitorState');
                if (saved) {
                    appState = JSON.parse(saved);
                }
            } catch (e) {
                console.warn('Storage not available:', e);
            }
        }
        */
        // Step 2: Call loadFromStorage() in the Initialize section below
        // Step 3: Call saveToStorage() after any state change (e.g., after adding URLs, saving email, etc.)

        // Simple hash function to detect changes
        function simpleHash(content) {
            if (!content) return '';
            const length = content.length;
            const first50 = content.substring(0, 50);
            const last50 = content.substring(Math.max(0, length - 50));
            return `${length}-${first50}-${last50}`;
        }

        // Format timestamp
        function formatTimestamp(date) {
            return new Date(date).toLocaleString('en-US', {
                month: 'short',
                day: 'numeric',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
        }

        // Update email service fields based on selection
        function updateEmailServiceFields() {
            const select = document.getElementById('email-service-select');
            const service = select.value;
            const fieldsContainer = document.getElementById('email-service-fields');
            const instructionsContainer = document.getElementById('email-service-instructions');
            const saveBtn = document.getElementById('save-email-btn');
            const testBtn = document.getElementById('test-email-btn');
            
            if (!service) {
                fieldsContainer.innerHTML = '';
                instructionsContainer.style.display = 'none';
                saveBtn.disabled = true;
                testBtn.disabled = true;
                return;
            }
            
            const serviceConfig = emailServices[service];
            instructionsContainer.innerHTML = serviceConfig.instructions;
            instructionsContainer.style.display = 'block';
            
            // Render fields for selected service
            fieldsContainer.innerHTML = serviceConfig.fields.map(field => `
                <div class="form-group">
                    <label class="form-label" for="email-field-${field.name}">${field.label}</label>
                    <input 
                        type="${field.type}" 
                        id="email-field-${field.name}" 
                        class="form-control" 
                        placeholder="${field.placeholder}"
                    >
                </div>
            `).join('');
            
            // Add recipient email field
            fieldsContainer.innerHTML += `
                <div class="form-group">
                    <label class="form-label" for="email-field-recipient">Notification Recipient Email</label>
                    <input 
                        type="email" 
                        id="email-field-recipient" 
                        class="form-control" 
                        placeholder="Where to send notifications"
                        value="${appState.email}"
                    >
                </div>
            `;
            
            saveBtn.disabled = false;
            testBtn.disabled = true; // Enable after saving
        }
        
        // Save email configuration
        function saveEmailConfig() {
            const service = document.getElementById('email-service-select').value;
            if (!service) {
                alert('Please select an email service');
                return;
            }
            
            const serviceConfig = emailServices[service];
            const config = {};
            let allFieldsFilled = true;
            
            // Collect all field values
            serviceConfig.fields.forEach(field => {
                const input = document.getElementById(`email-field-${field.name}`);
                const value = input.value.trim();
                if (!value) {
                    allFieldsFilled = false;
                }
                config[field.name] = value;
            });
            
            // Get recipient email
            const recipientInput = document.getElementById('email-field-recipient');
            const recipient = recipientInput.value.trim();
            if (!recipient || !recipient.includes('@')) {
                alert('Please enter a valid recipient email address');
                return;
            }
            
            if (!allFieldsFilled) {
                alert('Please fill in all fields');
                return;
            }
            
            appState.email = recipient;
            appState.emailService = service;
            appState.emailConfig = config;
            
            document.getElementById('test-email-btn').disabled = false;
            renderEmailDisplay();
            alert('‚úì Email configuration saved! You can now test it.');
        }
        
        // Test email
        async function testEmail() {
            if (!appState.emailService || !appState.email) {
                alert('Please configure email settings first');
                return;
            }
            
            const button = document.getElementById('test-email-btn');
            button.disabled = true;
            button.innerHTML = '<span class="spinner"></span> Sending...';
            
            try {
                const result = await sendEmail(
                    appState.email,
                    'Test notification from URL Monitor',
                    'https://example.com/test.txt',
                    5,
                    2,
                    'This is a test email to verify your configuration is working correctly.'
                );
                
                if (result.success) {
                    alert('‚úì Test email sent successfully! Check your inbox.');
                } else {
                    alert('‚úó Failed to send test email: ' + result.error);
                }
            } catch (error) {
                alert('‚úó Error sending test email: ' + error.message);
            }
            
            button.disabled = false;
            button.innerHTML = 'Send Test Email';
        }

        // Send email via Vercel backend
        async function sendEmail(recipientEmail, url, linesAdded, linesRemoved, diffPreview) {
            const VERCEL_API = 'https://your-vercel-project.vercel.app/api/send-email';
            // Fallback for local testing
            const API_ENDPOINT = VERCEL_API;
            
            try {
                const payload = {
                    email: recipientEmail,
                    url: url,
                    lines_added: linesAdded,
                    lines_removed: linesRemoved,
                    diff_preview: diffPreview,
                    timestamp: new Date().toISOString(),
                    service: appState.emailService,
                    ...appState.emailConfig
                };
                
                const response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    return { success: false, error: error.error || 'Unknown error' };
                }
                
                const result = await response.json();
                return { success: true, data: result };
            } catch (error) {
                console.error('Email sending error:', error);
                return { success: false, error: error.message };
            }
        }
        
        // Render email display
        function renderEmailDisplay() {
            const display = document.getElementById('current-email-display');
            if (appState.email && appState.emailService) {
                const serviceName = emailServices[appState.emailService].name;
                display.innerHTML = `
                    <div class="current-email">
                        ‚úì <strong>Email Configured:</strong> ${appState.email}<br>
                        <span style="font-size: var(--font-size-sm); color: var(--color-text-secondary);">Service: ${serviceName}</span>
                    </div>
                `;
            } else {
                display.innerHTML = '';
            }
        }

        // Add URL
        function addUrl() {
            const urlInput = document.getElementById('url-input');
            const url = urlInput.value.trim();
            
            if (!url) {
                alert('Please enter a URL');
                return;
            }
            
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                alert('URL must start with http:// or https://');
                return;
            }
            
            // Check if URL already exists
            if (appState.urls.some(item => item.url === url)) {
                alert('This URL is already being monitored');
                return;
            }
            
            const urlItem = {
                id: Date.now(),
                url: url,
                status: 'not_checked',
                lastCheck: null,
                lastHash: null,
                errorMessage: null
            };
            
            appState.urls.push(urlItem);
            urlInput.value = '';
            renderUrlList();
        }

        // Remove URL
        function removeUrl(id) {
            if (confirm('Are you sure you want to remove this URL from monitoring?')) {
                appState.urls = appState.urls.filter(item => item.id !== id);
                renderUrlList();
            }
        }

        // Fetch URL via Vercel backend
        async function fetchUrlContent(url) {
            const VERCEL_API = 'https://your-vercel-project.vercel.app/api/fetch-url';
            // Fallback to direct fetch (may have CORS issues)
            
            try {
                // Try Vercel backend first
                const response = await fetch(VERCEL_API, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ url: url })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    return { content: data.content, method: 'Vercel Backend' };
                }
            } catch (error) {
                console.warn('Vercel backend failed, trying direct fetch:', error);
            }
            
            // Fallback to direct fetch
            try {
                const response = await fetch(url, {
                    method: 'GET',
                    cache: 'no-cache'
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const content = await response.text();
                return { content: content, method: 'Direct Fetch' };
            } catch (error) {
                // Try CORS proxy as last resort
                const corsProxy = 'https://corsproxy.io/?';
                const proxyResponse = await fetch(corsProxy + encodeURIComponent(url));
                
                if (!proxyResponse.ok) {
                    throw new Error(`HTTP ${proxyResponse.status}: ${proxyResponse.statusText}`);
                }
                
                const content = await proxyResponse.text();
                return { content: content, method: 'CORS Proxy' };
            }
        }
        
        // Check single URL
        async function checkUrl(id, isAutomatic = false) {
            const urlItem = appState.urls.find(item => item.id === id);
            if (!urlItem) return;
            
            const button = document.querySelector(`button[onclick="checkUrl(${id})"]`);
            if (button) {
                button.disabled = true;
                button.innerHTML = '<span class="spinner"></span> Checking...';
            }
            
            try {
                const { content, method } = await fetchUrlContent(urlItem.url);
                const newHash = simpleHash(content);
                
                const previousHash = urlItem.lastHash;
                urlItem.lastHash = newHash;
                urlItem.lastCheck = Date.now();
                urlItem.errorMessage = null;
                
                if (previousHash === null) {
                    // First check - store content for future comparison
                    urlItem.status = 'no_change';
                    contentStore[urlItem.id] = { old: content, new: content };
                } else if (previousHash !== newHash) {
                    // Change detected - store both old and new content
                    const oldContent = contentStore[urlItem.id] ? contentStore[urlItem.id].new : '';
                    contentStore[urlItem.id] = { old: oldContent, new: content };
                    urlItem.status = 'changed';
                    
                    // Calculate diff statistics
                    const diff = calculateDiff(oldContent, content);
                    const stats = {
                        linesAdded: diff.filter(line => line.type === 'added').length,
                        linesRemoved: diff.filter(line => line.type === 'removed').length,
                        oldSize: oldContent.length,
                        newSize: content.length
                    };
                    
                    // Send email notification if configured
                    let emailStatus = 'not_sent';
                    if (appState.email && appState.emailService) {
                        emailStatus = 'pending';
                        const diffPreview = diff.slice(0, 10).map(line => {
                            const prefix = line.type === 'added' ? '+' : line.type === 'removed' ? '-' : ' ';
                            return prefix + ' ' + line.content;
                        }).join('\n');
                        
                        sendEmail(
                            appState.email,
                            urlItem.url,
                            stats.linesAdded,
                            stats.linesRemoved,
                            diffPreview
                        ).then(result => {
                            const notification = appState.notifications.find(n => n.id === notificationId);
                            if (notification) {
                                notification.emailStatus = result.success ? 'sent' : 'failed';
                                notification.emailError = result.success ? null : result.error;
                                renderNotificationList();
                            }
                        });
                    }
                    
                    const notificationId = addNotification(
                        urlItem.url, 
                        isAutomatic ? 'Automatic' : 'Manual', 
                        urlItem.id, 
                        stats, 
                        emailStatus
                    );
                } else {
                    // No change - update stored content
                    urlItem.status = 'no_change';
                    if (contentStore[urlItem.id]) {
                        contentStore[urlItem.id].old = contentStore[urlItem.id].new;
                        contentStore[urlItem.id].new = content;
                    } else {
                        contentStore[urlItem.id] = { old: content, new: content };
                    }
                }
            } catch (error) {
                urlItem.status = 'error';
                urlItem.lastCheck = Date.now();
                urlItem.errorMessage = error.message;
                
                // Check for CORS error
                if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                    urlItem.errorMessage = 'CORS error or network issue. The server may not allow cross-origin requests.';
                }
            }
            
            renderUrlList();
        }

        // Update interval setting
        function updateInterval() {
            const select = document.getElementById('interval-select');
            const value = select.value;
            
            if (value === 'manual') {
                appState.settings.intervalMinutes = null;
                // Disable auto-check if manual is selected
                if (appState.settings.autoCheckEnabled) {
                    document.getElementById('auto-check-toggle').checked = false;
                    toggleAutoCheck();
                }
            } else {
                appState.settings.intervalMinutes = parseInt(value);
            }
            
            // Restart auto-check if it's enabled
            if (appState.settings.autoCheckEnabled) {
                stopAutoCheck();
                startAutoCheck();
            }
        }
        
        // Toggle auto-check
        function toggleAutoCheck() {
            const toggle = document.getElementById('auto-check-toggle');
            const label = document.getElementById('toggle-label');
            const status = document.getElementById('auto-check-status');
            
            appState.settings.autoCheckEnabled = toggle.checked;
            
            if (toggle.checked) {
                const intervalSelect = document.getElementById('interval-select');
                if (intervalSelect.value === 'manual') {
                    alert('Please select a check interval before enabling auto-check.');
                    toggle.checked = false;
                    appState.settings.autoCheckEnabled = false;
                    return;
                }
                
                label.textContent = 'Enabled';
                status.style.display = 'block';
                startAutoCheck();
            } else {
                label.textContent = 'Disabled';
                status.style.display = 'none';
                stopAutoCheck();
            }
        }
        
        // Start auto-check
        function startAutoCheck() {
            if (!appState.settings.intervalMinutes) return;
            
            const intervalMs = appState.settings.intervalMinutes * 60 * 1000;
            nextCheckTime = Date.now() + intervalMs;
            
            // Set up the main check interval
            autoCheckInterval = setInterval(async () => {
                await performAutoCheck();
            }, intervalMs);
            
            // Set up countdown timer (updates every second)
            countdownInterval = setInterval(() => {
                updateCountdown();
            }, 1000);
            
            updateCountdown();
            
            // Perform first check immediately
            performAutoCheck();
        }
        
        // Stop auto-check
        function stopAutoCheck() {
            if (autoCheckInterval) {
                clearInterval(autoCheckInterval);
                autoCheckInterval = null;
            }
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            nextCheckTime = null;
        }
        
        // Perform automatic check
        async function performAutoCheck() {
            if (appState.urls.length === 0) {
                // Reset timer for next check
                const intervalMs = appState.settings.intervalMinutes * 60 * 1000;
                nextCheckTime = Date.now() + intervalMs;
                return;
            }
            
            appState.settings.lastAutoCheck = Date.now();
            document.getElementById('last-check-time').textContent = formatTimestamp(appState.settings.lastAutoCheck);
            
            // Check all URLs
            for (const urlItem of appState.urls) {
                await checkUrl(urlItem.id, true); // true = automatic check
            }
            
            // Reset timer for next check
            const intervalMs = appState.settings.intervalMinutes * 60 * 1000;
            nextCheckTime = Date.now() + intervalMs;
        }
        
        // Update countdown timer
        function updateCountdown() {
            if (!nextCheckTime) return;
            
            const now = Date.now();
            const remaining = Math.max(0, nextCheckTime - now);
            
            const hours = Math.floor(remaining / (1000 * 60 * 60));
            const minutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((remaining % (1000 * 60)) / 1000);
            
            const display = hours > 0 
                ? `${hours}h ${minutes}m ${seconds}s`
                : minutes > 0
                    ? `${minutes}m ${seconds}s`
                    : `${seconds}s`;
            
            document.getElementById('countdown-timer').textContent = display;
        }
        
        // Check all URLs
        async function checkAllUrls() {
            if (appState.urls.length === 0) {
                alert('No URLs to check. Please add some URLs first.');
                return;
            }
            
            const button = document.getElementById('check-all-btn');
            button.disabled = true;
            button.innerHTML = '<span class="spinner"></span> Checking All...';
            
            for (const urlItem of appState.urls) {
                await checkUrl(urlItem.id);
            }
            
            button.disabled = false;
            button.innerHTML = 'Check All Now';
        }

        // Calculate diff between two texts
        function calculateDiff(oldText, newText) {
            const oldLines = oldText.split('\n');
            const newLines = newText.split('\n');
            const diff = [];
            
            // Simple line-by-line diff using longest common subsequence approach
            const lcs = longestCommonSubsequence(oldLines, newLines);
            
            let oldIndex = 0;
            let newIndex = 0;
            let lcsIndex = 0;
            
            while (oldIndex < oldLines.length || newIndex < newLines.length) {
                // Check if current line is in LCS
                if (lcsIndex < lcs.length && 
                    oldIndex < oldLines.length && 
                    newIndex < newLines.length &&
                    oldLines[oldIndex] === lcs[lcsIndex] && 
                    newLines[newIndex] === lcs[lcsIndex]) {
                    // Unchanged line
                    diff.push({ type: 'unchanged', content: oldLines[oldIndex] });
                    oldIndex++;
                    newIndex++;
                    lcsIndex++;
                } else if (lcsIndex < lcs.length && 
                           newIndex < newLines.length && 
                           newLines[newIndex] === lcs[lcsIndex]) {
                    // Line was added
                    diff.push({ type: 'added', content: newLines[newIndex] });
                    newIndex++;
                } else if (lcsIndex < lcs.length && 
                           oldIndex < oldLines.length && 
                           oldLines[oldIndex] === lcs[lcsIndex]) {
                    // Line was removed
                    diff.push({ type: 'removed', content: oldLines[oldIndex] });
                    oldIndex++;
                } else if (oldIndex < oldLines.length && newIndex < newLines.length) {
                    // Changed line (shown as removed + added)
                    diff.push({ type: 'removed', content: oldLines[oldIndex] });
                    diff.push({ type: 'added', content: newLines[newIndex] });
                    oldIndex++;
                    newIndex++;
                } else if (oldIndex < oldLines.length) {
                    // Removed line at end
                    diff.push({ type: 'removed', content: oldLines[oldIndex] });
                    oldIndex++;
                } else if (newIndex < newLines.length) {
                    // Added line at end
                    diff.push({ type: 'added', content: newLines[newIndex] });
                    newIndex++;
                }
            }
            
            return diff;
        }
        
        // Longest Common Subsequence algorithm for diff
        function longestCommonSubsequence(arr1, arr2) {
            const m = arr1.length;
            const n = arr2.length;
            const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
            
            for (let i = 1; i <= m; i++) {
                for (let j = 1; j <= n; j++) {
                    if (arr1[i - 1] === arr2[j - 1]) {
                        dp[i][j] = dp[i - 1][j - 1] + 1;
                    } else {
                        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                    }
                }
            }
            
            // Reconstruct LCS
            const lcs = [];
            let i = m, j = n;
            while (i > 0 && j > 0) {
                if (arr1[i - 1] === arr2[j - 1]) {
                    lcs.unshift(arr1[i - 1]);
                    i--;
                    j--;
                } else if (dp[i - 1][j] > dp[i][j - 1]) {
                    i--;
                } else {
                    j--;
                }
            }
            
            return lcs;
        }
        
        // Show diff modal
        function showDiff(urlId) {
            const urlItem = appState.urls.find(item => item.id === urlId);
            if (!urlItem || !contentStore[urlId]) {
                alert('No diff data available for this URL.');
                return;
            }
            
            const { old: oldContent, new: newContent } = contentStore[urlId];
            const diff = calculateDiff(oldContent, newContent);
            
            // Calculate statistics
            const linesAdded = diff.filter(line => line.type === 'added').length;
            const linesRemoved = diff.filter(line => line.type === 'removed').length;
            const totalChanged = linesAdded + linesRemoved;
            const oldSize = oldContent.length;
            const newSize = newContent.length;
            const sizeChange = newSize - oldSize;
            
            // Create modal
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.onclick = (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            };
            
            const diffLines = diff.map(line => {
                const prefix = line.type === 'added' ? '+' : line.type === 'removed' ? '-' : ' ';
                const className = `diff-line diff-line--${line.type}`;
                const content = line.content || ' ';
                return `
                    <div class="${className}">
                        <div class="diff-line-prefix">${prefix}</div>
                        <div class="diff-line-content">${escapeHtml(content)}</div>
                    </div>
                `;
            }).join('');
            
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <div>
                            <h2 class="modal-title">üìä File Diff</h2>
                            <div class="modal-url">${escapeHtml(urlItem.url)}</div>
                        </div>
                        <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">‚úï</button>
                    </div>
                    <div class="modal-stats">
                        <div class="stat-item">
                            <div class="stat-label">Lines Added</div>
                            <div class="stat-value stat-value--added">+${linesAdded}</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Lines Removed</div>
                            <div class="stat-value stat-value--removed">-${linesRemoved}</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Total Changed</div>
                            <div class="stat-value">${totalChanged}</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">File Size</div>
                            <div class="stat-value">${formatBytes(oldSize)} ‚Üí ${formatBytes(newSize)}</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Size Change</div>
                            <div class="stat-value">${sizeChange >= 0 ? '+' : ''}${formatBytes(sizeChange)}</div>
                        </div>
                    </div>
                    <div class="modal-body">
                        <div class="diff-container">
                            ${diffLines || '<div class="empty-diff">No differences found</div>'}
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        // Helper function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Helper function to format bytes
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(Math.abs(bytes)) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        // Add notification
        function addNotification(url, checkType = 'Manual', urlId = null, stats = null, emailStatus = 'not_sent') {
            const notification = {
                id: Date.now(),
                url: url,
                urlId: urlId,
                timestamp: Date.now(),
                email: appState.email || 'Not configured',
                checkType: checkType,
                stats: stats,
                emailStatus: emailStatus, // 'not_sent', 'pending', 'sent', 'failed'
                emailError: null
            };
            
            appState.notifications.unshift(notification);
            renderNotificationList();
            return notification.id;
        }
        
        // Resend email for a notification
        async function resendEmail(notificationId) {
            const notification = appState.notifications.find(n => n.id === notificationId);
            if (!notification) return;
            
            if (!appState.email || !appState.emailService) {
                alert('Please configure email settings first');
                return;
            }
            
            notification.emailStatus = 'pending';
            notification.emailError = null;
            renderNotificationList();
            
            // Get diff preview
            const urlItem = appState.urls.find(u => u.id === notification.urlId);
            let diffPreview = 'Change detected';
            if (urlItem && contentStore[notification.urlId]) {
                const { old: oldContent, new: newContent } = contentStore[notification.urlId];
                const diff = calculateDiff(oldContent, newContent);
                diffPreview = diff.slice(0, 10).map(line => {
                    const prefix = line.type === 'added' ? '+' : line.type === 'removed' ? '-' : ' ';
                    return prefix + ' ' + line.content;
                }).join('\n');
            }
            
            const result = await sendEmail(
                notification.email,
                notification.url,
                notification.stats.linesAdded,
                notification.stats.linesRemoved,
                diffPreview
            );
            
            notification.emailStatus = result.success ? 'sent' : 'failed';
            notification.emailError = result.success ? null : result.error;
            renderNotificationList();
        }

        // Render URL list
        function renderUrlList() {
            const container = document.getElementById('url-list');
            
            if (appState.urls.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üìù</div>
                        <p>No URLs added yet. Add a URL above to start monitoring.</p>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = appState.urls.map(urlItem => {
                const statusLabels = {
                    'not_checked': 'Not Checked Yet',
                    'no_change': 'No Changes',
                    'changed': 'Change Detected!',
                    'error': 'Error Fetching'
                };
                
                return `
                    <div class="url-item">
                        <div class="url-item-header">
                            <div class="url-item-url">${urlItem.url}</div>
                            <div class="url-item-actions">
                                ${urlItem.status === 'changed' ? `
                                    <button 
                                        class="btn btn--sm btn--primary" 
                                        onclick="showDiff(${urlItem.id})"
                                    >
                                        View Diff
                                    </button>
                                ` : ''}
                                <button 
                                    class="btn btn--sm btn--secondary" 
                                    onclick="checkUrl(${urlItem.id})"
                                >
                                    Check Now
                                </button>
                                <button 
                                    class="btn btn--sm btn--danger" 
                                    onclick="removeUrl(${urlItem.id})"
                                >
                                    Remove
                                </button>
                            </div>
                        </div>
                        <div class="url-item-details">
                            <div class="url-detail">
                                <div class="url-detail-label">Status</div>
                                <div class="url-detail-value">
                                    <span class="status-badge status-badge--${urlItem.status}">
                                        <span class="status-indicator status-indicator--${urlItem.status}"></span>
                                        ${statusLabels[urlItem.status]}
                                    </span>
                                </div>
                            </div>
                            <div class="url-detail">
                                <div class="url-detail-label">Last Check</div>
                                <div class="url-detail-value">
                                    ${urlItem.lastCheck ? formatTimestamp(urlItem.lastCheck) : 'Never'}
                                </div>
                            </div>
                            ${urlItem.errorMessage ? `
                                <div class="url-detail" style="grid-column: 1 / -1;">
                                    <div class="url-detail-label">Error Details</div>
                                    <div class="url-detail-value" style="color: var(--color-error);">
                                        ${urlItem.errorMessage}
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Render notification list
        function renderNotificationList() {
            const container = document.getElementById('notification-list');
            
            if (appState.notifications.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üîï</div>
                        <p>No notifications yet. Notifications will appear here when URL changes are detected.</p>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = appState.notifications.map(notification => {
                const statsText = notification.stats ? 
                    `+${notification.stats.linesAdded} lines added, -${notification.stats.linesRemoved} lines removed` : 
                    'Changes detected';
                
                // Email status badge
                let emailStatusBadge = '';
                if (notification.emailStatus === 'sent') {
                    emailStatusBadge = '<span class="status-badge status-badge--no-change">‚úì Email Sent</span>';
                } else if (notification.emailStatus === 'pending') {
                    emailStatusBadge = '<span class="status-badge status-badge--changed">‚è≥ Sending...</span>';
                } else if (notification.emailStatus === 'failed') {
                    emailStatusBadge = '<span class="status-badge status-badge--error">‚úó Email Failed</span>';
                } else {
                    emailStatusBadge = '<span class="status-badge status-badge--not-checked">? Not Sent</span>';
                }
                
                return `
                    <div class="notification-item">
                        <div class="notification-header">
                            <div class="notification-title">üîî Change Detected</div>
                            <div class="notification-time">${formatTimestamp(notification.timestamp)}</div>
                        </div>
                        <div class="notification-url"><strong>URL:</strong> ${notification.url}</div>
                        ${notification.stats ? `
                            <div class="notification-email"><strong>Changes:</strong> ${statsText}</div>
                        ` : ''}
                        <div class="notification-email">üìß Recipient: <strong>${notification.email}</strong></div>
                        ${notification.emailError ? `
                            <div class="notification-email" style="color: var(--color-error); font-size: var(--font-size-xs);">
                                <strong>Error:</strong> ${notification.emailError}
                            </div>
                        ` : ''}
                        <div style="display: flex; gap: var(--space-8); align-items: center; margin-top: var(--space-8); flex-wrap: wrap;">
                            <span class="check-type-badge">${notification.checkType} Check</span>
                            ${emailStatusBadge}
                            ${notification.urlId && contentStore[notification.urlId] ? `
                                <button class="btn btn--sm btn--primary" onclick="showDiff(${notification.urlId})">
                                    View Diff
                                </button>
                            ` : ''}
                            ${notification.emailStatus === 'failed' || notification.emailStatus === 'not_sent' ? `
                                <button class="btn btn--sm btn--secondary" onclick="resendEmail(${notification.id})">
                                    Resend Email
                                </button>
                            ` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Initialize
        // FOR GITHUB USERS: Uncomment to load saved data on startup
        // loadFromStorage();
        
        renderEmailDisplay();
        renderUrlList();
        renderNotificationList();
        
        // Initialize settings display
        const toggle = document.getElementById('auto-check-toggle');
        toggle.checked = appState.settings.autoCheckEnabled;
        document.getElementById('toggle-label').textContent = appState.settings.autoCheckEnabled ? 'Enabled' : 'Disabled';
        
        if (appState.settings.autoCheckEnabled) {
            document.getElementById('auto-check-status').style.display = 'block';
            startAutoCheck();
        }
        
        if (appState.settings.lastAutoCheck) {
            document.getElementById('last-check-time').textContent = formatTimestamp(appState.settings.lastAutoCheck);
        }
    </script>
</body>
</html>